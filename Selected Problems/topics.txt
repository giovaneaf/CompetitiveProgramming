Approaches that can be used to solve each problem
1 - Digit DP
2 - Trie + Greedy (DFS)
3 - DP
4 - Geometry + Data Structre + irredutible fraction
5 - DP in DAG
6 - Data Structre (set)
7 - Binary Search
8 - Binary Search in answer + BFS
9 - DP
10 - Segment Tree
11 - Digit DP
12 - Euler Totient Function
13 - Recurrence Relation in matrix + Matrix fast exponentiation
14 - DP
15 - Maximum Spanning Tree (only change weight comparator) + LCA
16 - Dijkstra + DFS
17 - Matrix fast exponentiation
18 - Ad-hoc
19 - Dijkstra
20 - DP
21 - Simulation
22 - Binary search + Math (find formula)
23 - Ad-hoc
24 - Dijkstra
25 - DP
26 - Ad-hoc
27 - Graphs (Flood Fill)
28 - Segment Tree
29 - Geometry + DP
30 - DFS
31 - Nim + DP
32 - Inversion counting with Merge Sort/Seg Tree
33 - bitmask DP
34 - Binary Search + Max flow (Dinic)
35 - LCA
36 - Geometry + Data Structure
37 - DP + Greedy
38 - Binary Search + area union of rectangles
38.1 - Use log operation to turn multiplication in addition then it turns into the Assignment problem
39 - Floyd Warshall sorting vertices and answering queries offline while executing the algorithm
40 - Binary Search in answer
41 - Max Flow
42 - DP + Graphs
43 - DFS + Diameter in Trees + DP
44 - Greedy
45 - Combinatorics
46 - Geometry + DFS
47 - DFS
48 - DP in digits or Greedy
49 - Bipartite Matching
50 - DFS + Knapsack
51 - Sweep Line
51.1 - Ternary Search + Dijkstra
52 - DP + Seg Tree, store DP value in seg tree
53 - operations with set(balanced binary tree) + Ad-hoc
54 - Geometry + Greedy
55 - Greedy
56 - Max Flow
57 - Ad-hoc
58 - operations with set(balanced binary tree)
59 - DP in digits
60 - Segment Tree
61 - MST + LCA
62 - DP + GCD
63 - Don't forget about round (IMPORTANT!)
64 - Binary Search
65 - DP
66 - Chinese Remainder Theorem (CRT)
67 - Dijkstra
68 - DP on trees or I think there is a greedy approach
69 - BIT/Seg Tree + Sieve of Eratosthenes
70 - I didn't coded the solution, but it's ad-hoc keep possible angles from left to right and test all points in quadratic form
71 - Ad-hoc
72 - vertical DP (horizontal DP is cubic)
73 - Suffix Array + Greedy
74 - polynomial multiplication (FFT)
75 - DP
76 - Binary Search + Max Flow
77 - Graphs + Ad-hoc
78 - Binary Search + Circle Intersection
79 - Bitmask DP, note that a big palindrome string has smaller palindrome strings inside
80 - Ad-hoc
81 - Sweep Line
82 - DP
83 - DFS
84 - MST
85 - The solution is with string hasing (Rabin Karp) but because of the limits you can use brute force. I suggest using string hashing for practice.
86 - Simulation + Data structure + Ad-hoc
87 - DP
88 - DP
89 - Combinatorics
90 - Union Find / Disjoint Set Union (DSU)
91 - set operations
92 - DP
93 - Sparse Table (RMQ in O(1))
94 - DP
95 - Binary Search + Dijkstra
96 - Binary Search + Max Flow
97 - Dijkstra or Greedy
98 - GCD
99 - Max Flow
100 - Bitmask DP
101 - Use log operations to avoid underflow
102 - Dijkstra + Max Flow + Binary Search
103 - Bretschneider’s formula ->  Brahmagupta’s formula
104 - Geometry
105 - Sieve + irredutible fraction
106 - Math (Fibonacci)
107 - Brute force (use math to determine upper bounds)
108 - BFS in bitmask graph
109 - Binary search in answer
110 - DP
111 - Binary Search + Dijkstra + DP
112 - DP + Math (probability)
113 - Greedy
114 - Math (Inclusion-Exclusion principle) + Combinatorics or PD
115 - Compute Formula or Binary Search (Physics)
116 - Sparse Table
117 - Gray to Binary
118 - 3 BFS (particular steiner tree with k = 3 isn't NP-complete)
119 - Max Flow
120 - Geometry
121 - DP (sorting order is tricky)
122 - DP + Math (probability)
123 - Greedy + operations with set
124 - Combinatorics
125 - Dijkstra with new dimension (string position)
126 - 2-SAT + SCC
127 - Bipartite Graph + Konig Theorem (Find Maximal Independent Set)
128 - DP on number of artists
129 - Sparse Table
130 - Combinatorics with log to avoid overflow
131 - Strange but very useful formula to know
132 - DFS, tricky solution
133 - DP
134 - DP
135 - DP
136 - Max flow (Min cut Theorem)
137 - Math (Sieve)
138 - DFS's to compute what they want
139 - Max flow
140 - Flood Fill (I think there is a tricky case to handle)
141 - polynomial multiplication (FFT)
142 - Bipartite Matching
143 - BFS + Implementation
144 - Tricky Sweep Line with union find
145 - DP (kind of Matrix Chain Multiplication DP)
146 - Greedy (Idea from Huffman Code)
147 - DP (You can reduce a lot the number of states of the last dimension)
148 - Nim + DP
149 - DP
150 - Convex Hull + Point inside Polygon in O(log(n))
151 - Bitmask all the rows and make all transitions creating a recurrence matrix + Fast Matrix Exponentiation
152 - DAG + DP(Knapsack)
153 - Ad-hoc
154 - Convex Hull + Rotating Calipers
155 - Catalan Numbers
156 - SCC
157 - Nim + DP with optimization (splitting some connected components)
158 - Greedy (one starting from first to last then other to last to first)
159 - DP on Trees (you can split in two nodes)
160 - Binary Search + DFS
161 - DP in digits (binary digit)
162 - Greedy or bottom-up DP
163 - SCC (Condensation Graph)
164 - 2 stacks (normal stack and max stack)
165 - Geometry (rotate the polygon)
166 - Floyd Warshall sorting vertices and answering queries offline while executing the algorithm
167 - Math + Greedy
168 - Graph + Union Find (DSU)
169 - Math (Integral + splitting in intersections)
170 - DP
171 - Geometry + Data Structure + Binary Search
172 - Dijkstra
173 - Persistent data structure (e.g. persistent seg tree)
174 - Suffix structure (e.g. suffix array)
175 - Stable Marriage - hospitals/residents version (Gale-Shapley algorithm)
176 - Digit DP
177 - Recurrence relation + Matrix fast exponentiation
178 - DP
179 - DFS seg tree
180 - Kind of sudoku solver